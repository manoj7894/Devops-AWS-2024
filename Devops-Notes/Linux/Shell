-> What is Shell Scripting
Shell is executable file it containg mulitple commands that are executed sequently.

-> Types of shells (cat /etc/shells)
c shell
z shell
k shell
bash shell

echo $SHELL  --> To see the current shell
echo "$0"
which bash   --> To see the path of the shell
chsh -s /usr/bin/ksh  --> To change into the shell

Shebang
The first line of the script start with shebang
     #!/bin/bash
it invokes the bash shell and if it is not used in the shell script, the default shell will be used
Note: Script will also execute without shebang

To execute any shell script
1. sh <script.sh>
2. bash <script.sh>
3. ./ <script.sh>

To execute the script via ./ method, the owner should have the execute permission
If we forgot to pass the arguments, it will print as a empty at the variable place
chmod u+x <script.sh>

Variable
A variable is a character string to which we assign the value
The name of variable can contain only letters number and underscore(_)
To access any created variable, we have use $ symbol followed by the variable name
To pass the arguments/values to the script during the run time we can use $1, $2

Special variables

$0  ----> Gives the name of the script, that we are working
$#  ----> Gives the number of arguments passed to the script
$*  ----> Gives all the arguments passed to the script as a single string and store the arguments
          ./test.sh one two three
          Output:
          one two three
$@  ----> Gives all the arguments passed to the script as a separate item (array-like)
          ./test.sh one two three
          output:
          one
          two
          three

$$  ----> It give current shell PID
$!  ----> It give the last process PID which went into background
$?  ----> It give the current status of last command

Example command status codes
| Exit Code | Meaning                          |
| --------- | -------------------------------- |
| `0`       | Success                          |
| `1`       | General error                    |
| `2`       | Incorrect usage                  |
| `126`     | Command found but not executable |
| `127`     | Command not found                |
| `130`     | Script terminated (Ctrl+C)       |

set -x ----> it helps us to debug the code ( Prints all the commands and their arguments being executed)
set +x  ----> This is used to stop the debugging mode on particular location/line in the script
set -e ----> To stop the script immediately when the command exits with non-zero status


ps -c ---> It is used to check the major running process on the server
ex:
sleep 30 &
echo $!

-> Loops in Shell Scripting
We have two types of loops
1) while loop
2) for loop

-> While loop
while will execute the statement until condition become false
While loop can also be used to read the file line by line (iterating the file)

while [ condition ]
do
     statement
done

while [ condition ] ; do
     statement
done

-> For loop
It is used to execute the statement for the given range of values

syntax:
for i in var1 var2 var3
do
 statement
done

for i in { 0....10} ----> The variable values goes from 0 to 10
1st iteration
i = 0
2nd iteration
i = 1
3rd iteration
i = 2
.
.
.
at 12th iteration it will come out of the loop

for i in {0...100..10}  ----> The variable varies will go from 0 to 100 with the increment of 10 [ i=10, i=20 ......]

for i in $*  ----> variable will take all the arguments passes to the script

sh script.sh 1 2 3 4 5
for i in $*
i=1
i=2
i=3
i-4
i=5




--------------------------------------------------------------------------------------------------------------------
Cronjob
The cronjob is Linux command used for scheduling of tasks, to be executed sometime in future

syntax:

*   *    *    *      *   command
min hour date Month day  sh script.sh

0 ---> Sunday
1 ---> monday
2 ---> Tuesday
3 ---> Wednesday
4 ---> Thursday
5 ---> Friday

10am on every sunday  ----> 00 */10 * * 0 sh script.sh
11am on every monday and friday --> 00 */11 * * 1,5 sh script.sh
11am on every monday to friday --> 00 */11 * * 1-5 sh script.sh
every 15min                    --> */15 * * * * sh script.sh
every 1min                     --> * * * * * sh script.sh
10pm on july 8th on monday     --> 00 22 08 07 01 sh script.sh 


crontab ----> This is the file contains all the cronjob entries to be run at a specific time
crontab -e ---> To edit or create the cronjobs
crontab -l ----> To list all the existing cronjobs
crontab -r ----> It is used to remove(delete) the current user all cronjobs from crontab file

Note: Cronjobs are specific to particular user only 

sudo yum install cronie
sudo systemctl status crond
sudo systemctl start crond
sudo systemctl stop crond
sudo susyemctl restart crond
--------------------------------------------------------------------------------------------------------------------
mailx

sudo yum install mailx -y   # Amazon Linux
sudo apt install mailutils -y  #ubuntu

vi ~/.mailrc   --> Create the file

set smtp-use-starttls
set ssl-verify=ignore
set smtp-auth=login
set smtp=smtp://smtp.gmail.com:587
set smtp-auth-user=ðŸ”´your-email@gmail.com
set smtp-auth-password=ðŸ”´your-app-password
set from="ðŸ”´your-email@gmail.com"

IMPORTANT: You cannot use your normal Gmail password.
You must generate an App Password. See next step.
Make sure there is no space in App Password.

3. Enable App Password in Gmail
Steps:
1. Go to: https://myaccount.google.com/apppasswords
2. Login and generate an App Password for "Mail"
3. It will show you a 16-character password â€” use this in the smtp-auth-password
field in .mailrc
This works only if 2-Step Verification is enabled on your Google account.

4. Test sending a mail
echo "This is a test from EC2" | mailx -s "Hello from EC2" your-gmailaddress@gmail.com


syntax:
echo "content" | mail  -s "subject" -c "cc" -b "bcc" <emaild_id>

echo "the disk size is full" | mail -s "disk usage alert" -c "abc@gmail.com" -b "test@gmail.com,xyz@gmail.com" sstraining@gmail.com

-> What is case statement
A case statement is used to execute different blocks of code based on pattern matching

-> Why use case statement?
Easier to read
Faster execution
Best for menu-driven scripts
Pattern matching support (*, |, ?)

#!/bin/bash
echo "enter the value for n"
read n
case $n in
1) echo "entered number is 1"
;;
2) echo "entered number is 2"
;;
3) echo "entered number is 3"
;;
*) echo "invalid input"
;;
esac
---------------------------------------------------------------------------------------------------------------------------------------------------

Arithmetic Operators ( +,-,*,/)

syntax;
sum=`expr $1 + $2`
sub=`expr $1 - $2`
prod=`expr $1 \* $2`
div=`expr $1 / $2`

Example1:
#!/bin/bash
echo "Enter the value for number1"
read num1
echo "Enter the value for number2"
read num2

sum=`expr $num1 + $num2`
sub=`expr $num1 - $num2`
prod=`expr $num1 \* $num2`
div=`expr $num1 / $num2`

echo "The sum of 2 no's is $sum"
echo "The sub of 2 no's is $sub"
echo "The prod of 2 no's is $prod"
echo "The div of 2 no's is $div"

or

#!/bin/bash
echo "Enter the value for number1"
read num1
echo "Enter the value for number2"
read num2

sum=$(($num1 + $num2))
sub=$(($num1 - $num2))
prod=$(($num1 * $num2))
div=$(($num1 / $num2))

echo "The sum of 2 no's is $sum"
echo "The sub of 2 no's is $sub"
echo "The prod of 2 no's is $prod"
echo "The div of 2 no's is $div"
----------------------------------------------------------------------------------------------------------------
Relational Operators -----> These are used to compare the values
----------------------------------------------------------------------------------------------------------------
string ----------> The below operators should be used when we are comparing the strigs
==  ----> equal
!=  ----> not equal
<   ----> lesser than
<=  ----> lesser than or equals
>   ----> greater than
>=  ----> greater than or equal

Number -------> The below operators should be used when we are comparing the numbers
-eq  ----> equal
-ne  ----> not equal
-lt   ----> lesser than
-le  ----> lesser than or equals
-gt   ----> greater than
-ge  ----> greater than or equal
------------------------------------------------------------------------------------------------------------
File Operators

This can be used check for both files and directories in current working directory

[ -f $name ] ----> To check if it is a file
[ -d $name ] ----> To check if it is a directory
[ -r $name ] ----> To check if the file/dir has got the read permission
[ -w $name ] ----> To check if the file/dir has got the write permission
[ -x $name ] ----> To check if the file/dir has got the execute permission
[ -s $name ] ----> Checks if file/dir exists and is not empty
[ -e $name ] ----> Checks if both file or directory exists	

Note: The script always checks only for the owner not for the group and others
----------------------------------------------------------------------------------------------------------
Normal Scripts
-> Example1:- Install packages and status

#!/bin/bash
set -x
sudo yum install docker -y
sudo systemctl start docker
sudo systemctl enable docker
sudo systemctl status docker

sudo yum install cornie -y
sudo systemctl start crond
sudo systemctl enable crond
sudo systemctl status crond


-> Example2:- Pass the arguments

#!/bin/bash
set -x
echo "pass the Arguments using $1 and $2"
echo "This is $1, I am from $2"


#!/bin/bash
set -x
echo "pass the Arguments using $1 and $2"
name=$1
place=$2
echo "This is $name, I am from $place"


#!/bin/bash
set -x
echo "pass the Arguments using read"
echo "Enter the name"
read name
echo "Enter the place"
read place
echo "This is $name, I am from $place"


#!/bin/bash
set -x
echo "Print the varible using arguments $1 and $2"
echo "$0"
echo "$#"
echo "$*"
echo "$@"
echo "$$"
echo "$!"
echo "$?"

Note: If we miss any arguments to the command it will print like empty space
-----------------------------------------------------------------------------------------------------------------------
# Arithmetic and relational scripts
# If else scripts
-> Example1:

#!/bin/bash
set -x
echo "print the Arithmetic values"
echo "Enter Number One"
read n1
echo "Enter Number Two"
read n2

sum=$((n1 + n2))
sub=$((n1 - n2))
multi=$((n1 * n2))
div=$((n1 / n2))
echo $sum
echo $sub
echo $multi
echo $div


-> Example2: Check the entered number is 5 or not

#!/bin/bash
set -x
echo "Enter the Number"
read n

if [ $n -eq 5 ]; then
  echo "Enter number is $n"
else
  echo "Enter number is not $n"
fi


-> Example3: Check the Biggest Two Numbers

#!/bin/bash
set -x
echo "Enter the Number One"
read n1
echo "Enter the Number Two"
read n2

if [ $n1 -gt $n2 ]; then
  echo "Number one $n1 is Bigger"
else
  echo "Number two $n2 is Bigger"
fi


-> Example4: Check the Biggest Three Numbers

#!/bin/bash
set -x
echo "Enter the Number One"
read n1
echo "Enter the Number Two"
read n2
echo "Enter the Number Three"
read n3

if [ $n1 -gt $n2 ] && [$n1 -gt $n2]; then
  echo "Number one $n1 is Bigger"
elif [ $n2 -gt $n3 ] && [ $n2 -gt $n1 ]; then
  echo "Number two $n2 is Bigger"
else
  echo "Number three $n3 is Bigger"
fi


-> Example5: Find the file is exist or not 

#!/bin/bash
set -x
echo "Enter the file name"
read filename

if [ -f $filename ]; then
  echo "$filename is exist"
else
  echo "$filename is not exist"
fi


-> Example5: Find the file is exist or not and it has excute permission or not, if not give execute permission
find . -maxdepth 1 -type f --name filename -perm 111 | sudo chmod 111 filename | ls -l

#!/bin/bash
set -x
echo "Enter the file name"
read filename

if [ -f $filename ]; then
  echo "$filename is exist"
  if [ -x $filename ]; then
    echo "$filename has excution permission"
  else
    echo "$filename has not excution permission, we have provide the permission"
    sudo chmod +x $filename
  fi
else
  echo "$filename is not exist"
fi


-> Example5: Find the file is exist or not in directory and it has excute permission or not, if not give execute permission and If it has data it should be display resever order
#!/bin/bash
set -x
echo "Enter the Directory name"
read "dirname"
echo "Enter the file name"
read filename

if [ -d $dirname ]; then
     echo "$dirname is exist"
     cd $dirname
     if [ -f $filename ]; then
          echo "$filename is exist"
          if [ -x $filename ]; then
               echo "$filename has execution permission"
          else
               sudo chmod +x $filename
          fi
               while read line 
               do
                    echo $line
               done < $filename 
     else
          echo "$filename is not exist"
     fi
else
     echo "$dirname is not exist"
fi

-> Example6: Write the script to check if disksize is more than 25

#!/bin/bash
echo "Find the disk size"
DISK=`df -h | sed -n '5p' | awk '{print $5}' | sed 1s/%//ig`

if [ $DISK -ge 25 ]; then
     echo "Disk is $DISK grater than 25"
else
     echo "Disk is $DISK less than 25"
fi
-----------------------------------------------------------------------------------------------------------------------
#While loop

-> Example7: Sum of n numbers

#!/bin/bash
set -x
echo "Enter the number"
read n
sum=0
i=1

while [ $i -le $n ]
do
     sum=$((sum + i))
     i=$((i + 1))
done
echo "Sum of numbers is $sum"


#!/bin/bash
set -x
read n
sum=0

while [ $n -gt 0 ]
do
        sum=$(($sum + $n))
        n=$((n - 1))
done
echo "Sum of n number is $sum"



-> Example8: Factorial of n numbers

#!/bin/bash
set -x
echo "Enter the number"
read n
fact=1
i=1

while [ $i -le $n ]
do
     fact=$((fact * i))
     i=$((i + 1))
done
echo "Sum of factorical numbers is $fact"

  

-> Example9: Sum of n even numbers

#!/bin/bash
set -x
echo "Enter the even number"
read n
sum=0
i=2

while [ $i -le $n ]
do
     sum=$((sum + i))
     i=$((i + 2))
done
echo "Sum of odd numbers is $sum"


-> Example10: Sum of n odd numbers

#!/bin/bash
set -x
echo "Enter the odd number"
read n
sum=0
i=1

while [ $i -le $n ]
do
     sum=$((sum + i))
     i=$((i + 2))
done
echo "Sum of odd numbers is $sum"


-> Example11: Read the file line by line

#!/bin/bash
echo "Read content in file"
read filename

while read line
do
     echo $line
done < $filename


-> Example12: Read the file line by line and count the character in file

#!/bin/bash
echo "Read content in file"
read filename

while read line
do
     echo $line | wc -c
done < $filename


-> Example13: Read the file line by line and count the character in file and out should be display like below
1 : 28
2 : 24

#!/bin/bash
echo "Read content in file"
read filename
l=1

while read line
do
     number=`echo $line | wc -c`
     l=$((l+1))
     echo "$l: $number"
     
done < $filename


-> Example14: Write the script to get the names with age more than 20 years

no name age
1 abc 15
2 def 31
3 xyz 30
4 ret 20

#!/bin/bash
set -x
echo "Enter filename"
read filename
sed '1d' $filename > tmp

while read line
do
     age=`echo $line | awk '{print $3}'`
     if [ age -ge 20 ]; then
          echo $line | awk '{print $2}'
     else
          echo "All the age are below than 20"
     fi
done < tmp
------------------------------------------------------------------------------------------------------------------------
# For loop
-> Example1: find the sum of all the numbers passed to the script
1 2 3 4 5

#!/bin/bash
set -x
sum=0

for i in $*
do
     sum=$((sum + i))
done
echo "sum of the number is $sum"


-> Example2: find the factorical of all the numbers passed to the script
1 2 3 4 5

#!/bin/bash
set -x
fact=1

for i in $*
do
     fact=$((fact * i))
done
echo "sum of the factorical number is $fact"


-> Example2: Find the factorial of a given set of numbers
1 2 3 4 5
output:
Factorial of 1 is 1
Factorial of 2 is 2
Factorial of 3 is 6
Factorial of 4 is 24
Factorial of 5 is 120

#!/bin/bash
for i in $*
do
     fact=1
     n=$i
     while [ $n -gt 0 ]
     do
          fact=$((fact * n))
          n=$((n - 1))
     done
     echo "Factorial of $i is $fact"
done



-> Example3: Write the script to check, if the particular service is down and if its down bring it up and alert us

#!/bin/bash
servicename="sshd crond"
for i in $servicename
do
     output=`sudo systemctl is-active $i`
     if [ $output != active ]; then
          echo "$i are in issue" | mailx -s "Alert on $i" varmapotthuri4@gmail.com
          sudo systemctl start $i
          sudo systemctl enable $i
          sudo systemctl status $i
     else
          echo "Services are in active status"
     fi
done
---------------------------------------------------------------------------------------------------------------------
# Case Statement scripts
-> Example1: write the script based on the input day
monday ----> Today is monday
tuesday ---> Today is tuesday
wednesday ---> Today is wednesday
any other input ---> invalid input

#!/bin/bash
echo "Enter the day"
read day

case $day in
monday) echo "Today is monday"
;;
tuesday) echo "Today is tuesday"
;;
wedensday) echo "Today is wedensday"
;;
*) echo "Invaild output"
;;
esac


-> Example2: Write the script to perform the menu based operations
1. search/find for the files based on the given input
2. check the if the file exist or not by the given name
3. create the softlink for the file
4. invalid input

#!/bin/bash
echo "perform the menu based operations"
read n

case $n in
1) echo "Find the files"
   read filename
   find . -maxdepth 1 -type f -name $filename
;;
2) echo "Find the file"
   read filename
   if [ -f $filename ]; then
     echo "$filename is exist"
   else
     echo "$filename is not exist"
   fi
;;
3) echo "create soft link"
   echo "Enter the file name"
   read filename
   filepath=$(realpath "$filename")
   echo "Enter the soft link name"
   read linkname
   path="pwd"
   ln -s $filepath $linkname
;;
4) echo "invalid output"
;;
esac
          


         










